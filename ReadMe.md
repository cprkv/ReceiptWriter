# ReceiptWriter

## Как собирать

- `dotnet build` (требуется .NET 8.0 SDK)

## Как запускать

- `dotnet run --project ReceiptWriter.Console/ReceiptWriter.Console.csproj` - пример работы из консоли
- `dotnet test` - тесты

## Структура проекта

- `ReceiptWriter` - библиотека с решением задачи.
- `ReceiptWriter.Console` - консольное приложение - спрашивает денежную стоимость через stdin, печатает на консоль
  их словесную формулировку.
- `ReceiptWriter.Tests` - юнит тесты.

## Шаги решения

- 15 минут: думал над алгоритмом решения
- 5 минут: создал солюшен структуру проекта, настроил автоформаттер
- 20 минут: структура классов с заглушками и юнит тесты (TDD)
- 15 минут: реализация Dollars.TryParse
- 40 минут: реализация NumberToWordsConverter.ToWords
- 5 минут: реализация Dollars.FormatToWords
- 5 минут: написал небольшое консольное приложение
- 25 минут: сверил реализацию с задачей, подправил, порефакторил тесты

Итого: 2 часа и 10 минут.

## Что можно улучшить

1. Класс `Dollars` и `NumberToWordsConverter` связаны с английским языком. Стоит языки выделять отдельно. То есть, метод
   форматирования денег должен выглядеть так: `Dollars.FormatToWords(ILanguage lang)`, и `NumberToWordsConverter` станет
   реализацией `ILanguageNumbersConverter` вместо статичного класса.
2. Я бы запросил больше примеров форматирования, потому что из тестового задания напрямую не следует, нужно ли писать "
   zero", если количество долларов пусто; тоже самое с центами. Ещё "no commas are required for the input", - значит ли
   это что во входных данных они всё же могут встретиться, и требуется ли обязательно символ "."?
3. Можно избежать многих ветвлений логики в классе `NumberToWordsConverter` за счёт того чтобы складывать части ответа в
   `List<string>` и позже объединять, но это _может_ быть менее производительно (по аллокациям памяти). В данном случае
   хотелось бы понять, насколько производительность критична и, может, побенчмаркать два решения, если действительно
   важна. А если не важна то и решение стоит упростить.
4. `Dollars.TryParse` не сообщает причину почему парсинг не прошёл. Эту задачу можно решить подходящими эксепшенами, но
   они не всегда уместны (по перформансу), поэтому я решил делать без них.
